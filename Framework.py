# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UiAgF71UZkL8L4F9-NRSlLVMbfDMGpf4
"""

import numpy as np
from matplotlib import pyplot as plt
import pandas as pd
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers, callbacks
from keras.wrappers.scikit_learn import KerasClassifier
from sklearn.model_selection import GridSearchCV
import tensorflow_datasets as tfds
from Model import Model
from Dataset import Dataset

fig_size=(9, 3)
def plot_rul(pred=None, target=None,
        stddev=None,
        q1_3=None,
        same_scale=True,
        figsize=fig_size, autoclose=True):
    if autoclose:
        plt.close('all')
    plt.figure(figsize=figsize)
    if target is not None:
        plt.plot(range(len(target)), target, label='target',
                color='tab:orange')
    if pred is not None:
        if same_scale or target is None:
            ax = plt.gca()
        else:
            ax = plt.gca().twinx()
        ax.plot(range(len(pred)), pred, label='pred',
                color='tab:blue')
       # if stddev is not None:
       #     ax.fill_between(range(len(pred)),
       #             pred-stddev, pred+stddev,
       #             alpha=0.3, color='tab:blue', label='+/- std')
        if q1_3 is not None:
            ax.fill_between(range(len(pred)),
                    q1_3[0], q1_3[1],
                    alpha=0.3, color='tab:blue', label='1st/3rd quartile')
    plt.legend()
    plt.tight_layout()
    plt.show()

class Rul_Framework():
  def __init__(self,input_features, rul_feature, full_data):
    self.model=Model(input_features,'rul')
    self.dataset=Dataset(full_data)
    self.rul_feature=rul_feature

  def build_net(self,hidden,optimizer='Adam',loss='mae'):
    self.model.build_net(hidden,optimizer,loss)

  def import_net(self,net):
    self.net=net

  def rul_estimation_with_transfer(self,feature,ratio,batch_size=10, validation_split=0.2, epochs=20, verbose=1, callbacks=[tf.keras.callbacks.EarlyStopping(patience=2)]):
    self.dataset.compute_rul(self.rul_feature)
    self.tr_set , self.ts_set = self.dataset.split_by_feature(feature,ratio=0.8)
    return self.model.train(self.tr_set,batch_size=10, validation_split=0.2, epochs=20, verbose=1, callbacks=[tf.keras.callbacks.EarlyStopping(patience=2)])

  def rul_estimation(self,ratio,batch_size=10, validation_split=0.2, epochs=20, verbose=1, callbacks=[tf.keras.callbacks.EarlyStopping(patience=2)]):
    self.dataset.compute_rul(self.rul_feature)
    self.tr_set , self.ts_set = self.dataset.random_split(ratio=0.8)
    return self.model.train(self.tr_set,batch_size=10, validation_split=0.2, epochs=20, verbose=1, callbacks=[tf.keras.callbacks.EarlyStopping(patience=2)])
    
  def print_prediction_on_test(self,stop):
    plot_rul(self.model.predict(self.ts_set)[:stop],self.ts_set['rul'][:stop])

  def print_prediction_on_training(self,stop):
    plot_rul(self.model.predict(self.tr_set)[:stop],self.tr_set['rul'][:stop])

  def print_prediction_on_set(self,input_set, stop):
    plot_rul(self.model.predict(input_set)[:stop],input_set['rul'][:stop])

  def mae_on_trainining(self):
    return tf.keras.losses.mean_absolute_error(self.tr_set['rul'], self.model.predict(self.tr_set))

  def mae_on_test(self):
    return tf.keras.losses.mean_absolute_error(self.ts_set['rul'], self.model.predict(self.ts_set))

  def mae_on_set(input_set):
    return tf.keras.losses.mean_absolute_error(input_set['rul'], self.model.predict(input_set))